### Item32 谨慎地并用泛型和可变参数

> Varargs methods (Item 53) and generics were both added to the platform in Java 5, so you might expect them to interact gracefully; sadly, they do not. The purpose of varargs is to allow clients to pass a variable number of arguments to a method, but it is a *leaky abstraction*: when you invoke a varargs method, an array is created to hold the varargs parameters; that array, which should be an implementation detail, is visible. As a consequence, you get confusing compiler warnings when varargs parameters have generic or parameterized types.

可变参数方法和泛型是在Java5中一起假如到Java平台中来的，因此你可能会期望它俩能很好的互相作用；遗憾的是，他们不能。设计可变参数的目的是允许客户端给一个方法传递可变数量的参数，但是它是一个“技术露底”：当你在调用一个可变参数方法的时候，会创建一个数组来持有这些可变参数；而这个数组，本应该是实现细节，却是可见的。因此，当你的可变参数中有泛型或者参数化类型的时候，你可能会得到一个莫名其妙的编译器警告。

> Recall from Item 28 that a non-reifiable type is one whose runtime representation has less information than its compile-time representation, and that nearly all generic and parameterized types are non-reifiable. If a method declares its varargs parameter to be of a non-reifiable type, the compiler generates a warning on the declaration. If the method is invoked on varargs parameters whose inferred type is non-reifiable, the compiler generates a warning on the invocation too. The warnings look something like this:

回顾一下Item28里说的，不可具体化类型就是一个运行时信息比编译时少的类型，而且基本所有的泛型和参数化类型都是不可具体化的。如果一个方法声明的可变参数是不可具体化的类型，编译器就会在这个声明上生成一个警告。如果这个方法被调用的时候，其可变参数的推导类型是不可具体画的，编译器也会在这个调用上生成一个警告。这个警告大概长这样：

```java
warning: [unchecked] Possible heap pollution from
       parameterized vararg type List<String>
```

> *Heap pollution* occurs when a variable of a parameterized type refers to an object that is not of that type [JLS, 4.12.2]. It can cause the compiler’s automatically generated casts to fail, violating the fundamental guarantee of the generic type system.

堆泄露会在一个参数化类型变量指向一个不是这个类型的对象的时候出现 [JLS, 4.12.2]。它会导致编译器自动生成的转换失败，从而破坏了泛型系统的基本保证。

> For example, consider this method, which is a thinly disguised variant of the code fragment on page 127:

比如，下面这个方法，是Item28里的代码片段稍加修改得到的：

```java
// Mixing generics and varargs can violate type safety! 
static void dangerous(List<String>... stringLists) {
	List<Integer> intList = List.of(42);
	Object[] objects = stringLists;
	objects[0] = intList; // Heap pollution 
  String s = stringLists[0].get(0); // ClassCastException
}
```

> This method has no visible casts yet throws a ClassCastException when invoked with one or more arguments. Its last line has an invisible cast that is generated by the compiler. This cast fails, demonstrating that type safety has been compromised, and **it is unsafe to store a value in a generic varargs array parameter.**

这个方法没有显示的类型转化，但是在使用一个或者多个参数进行调用的时候，会生成ClassCastException。代码的最后一行里有一个编译器生成的不可见的类型转换，这个转换失败了，也就意味着类型安全收到了威胁，**所以将值保存在泛型可变数组参数里时不安全的。**

> This example raises an interesting question: Why is it even legal to declare a method with a generic varargs parameter, when it is illegal to create a generic array explicitly? In other words, why does the method shown previously generate only a warning, while the code fragment on page 127 generates an error? The answer is that methods with varargs parameters of generic or parameterized types can be very useful in practice, so the language designers opted to live with this inconsistency. In fact, the Java libraries export several such methods, including Arrays.asList(T... a), Collections.addAll(Collection<? super T> c, T... elements), and EnumSet.of(E first, E... rest). Unlike the dangerous method shown earlier, these library methods are typesafe.

那么，一个有趣的问题就来了，为什么显式的创建一个泛型数组是非法的，而声明一个有泛型的可变参数却是合法的呢？换句话说，就是，为什么前面这个方法只是生成了一个warning，而Item28里的代码就或生成一个error呢？答案是因为泛型或者参数化类型的可变参数方法，在实际应用中实在是太有用了。所以语言设计者，选择了就这么前后矛盾着。事实上，在Java类库中有很多这样的方法，包括Arrays.asList(T... a)，Collections.addAll(Collection<? super T> c, T... elements)，和 EnumSet.of(E first, E... rest)。和前面这个dangerous方法不一样的是，这些类库方法都是类型安全的。

> Prior to Java 7, there was nothing the author of a method with a generic varargs parameter could do about the warnings at the call sites. This made these APIs unpleasant to use. Users had to put up with the warnings or, preferably, to eliminate them with @SuppressWarnings("unchecked") annotations at every call site (Item 27). This was tedious, harmed readability, and hid warnings that flagged real issues.

在Java7之前的版本中，泛型可变参数方法的设计者，对于每次调用方法都要生成的警告毫无办法。这使得这个API用起来很不舒服。用户必须要忍受这些警告，或者，在每次调用的时候都使用@SuppressWarnings("unchecked") 注解，后面这个方法要稍微好些。这么做都非常单调，并且会影响可读性，还会掩盖一些实际问题生成的警告。

> In Java 7, the SafeVarargs annotation was added to the platform, to allow the author of a method with a generic varargs parameter to suppress client warnings automatically. In essence, **the** **SafeVarargs** **annotation constitutes a promise by the author of a method that it is typesafe.** In exchange for this promise, the compiler agrees not to warn the users of the method that calls may be unsafe.

在Java7中，SafeVarargs注解被添加到了平台里，这个注解可以允许泛型可变参数方法的作者自动地禁止客户端的警告。本质上，**SafeVarargs注解就代表着这个方法的作者的承诺，保证这个方法是类型安全的**。有了这个承诺，编译器就可以不用再警告 这个方法的用户 这个调用可能是不安全的了。

> It is critical that you do not annotate a method with @SafeVarargs unless it actually *is* safe. So what does it take to ensure this? Recall that a generic array is created when the method is invoked, to hold the varargs parameters. If the method doesn’t store anything into the array (which would overwrite the parameters) and doesn’t allow a reference to the array to escape (which would enable untrusted code to access the array), then it’s safe. In other words, if the varargs parameter array is used only to transmit a variable number of arguments from the caller to the method—which is, after all, the purpose of varargs—then the method is safe.

只有当方法是真正类型安全的时候，才使用@SafeVarargs注解，这是非常重要的。那么什么情况能保证类型安全呢？回顾一下，方法被调用的时候，会创建一个泛型数组来持有可变参数。如果这个方法不往这个数组里存放任何的东西（这可能会覆盖掉参数），也不让这个数组的引用泄露（*赋值给其他变量，作为方法的返回值*）（这可能会允许一些不可信的代码访问到这个数组），就可以保证其类型安全。换句话说，如果这个可变参数数组只用来从调用者那里传递可变数量的参数给方法（当然，这也是可变参数真正的目的），那么这个方法就是安全的。

> It is worth noting that you can violate type safety without ever storing anything in the varargs parameter array. Consider the following generic varargs method, which returns an array containing its parameters. At first glance, it may look like a handy little utility:

需要注意的是，即使不往可变参数数组里存放任何东西，也可能会破坏类型安全。比如下面这个泛型可变参数方法，返回了包含其可变参数的数组。乍一看，还好像是一个方便的小工具。代码如下：

```java
// UNSAFE - Exposes a reference to its generic parameter array!
   static <T> T[] toArray(T... args) {
       return args;
}
```

> This method simply returns its varargs parameter array. The method may not look dangerous, but it is! The type of this array is determined by the compile-time types of the arguments passed in to the method, and the compiler may not have enough information to make an accurate determination. Because this method returns its varargs parameter array, it can propagate heap pollution up the call stack.

这个方法只是简单地返回了其可变参数数组。这个方法看起来好像没什么危害，但是它确实很危险。数组的类型，是由编译时传递给这个方法的参数的类型决定的，并且编译器并没有足够的信息来做出正确的决定。由于这个方法直接放回了其可变参数数组，它可以将对污染传播到其调用栈里。

> To make this concrete, consider the following generic method, which takes three arguments of type T and returns an array containing two of the arguments, chosen at random:

为了说得更清楚一些，看看下面这个泛型的方法，有三个类型为T的参数，返回一个包含其中随机两个参数的数组。代码如下：

```java
static <T> T[] pickTwo(T a, T b, T c) {
       switch(ThreadLocalRandom.current().nextInt(3)) {
         case 0: return toArray(a, b);
         case 1: return toArray(a, c);
         case 2: return toArray(b, c);
			}
       throw new AssertionError(); // Can't get here
   }
```

> This method is not, in and of itself, dangerous and would not generate a warning except that it invokes the toArray method, which has a generic varargs parameter.

这个方法本身并没有很危险，也不会生成任何的warning，除非它调用了有泛型可变参数的toArray方法。（*可它不就是调用了嘛*）。

> When compiling this method, the compiler generates code to create a varargs parameter array in which to pass two T instances to toArray. This code allocates an array of type Object[], which is the most specific type that is guaranteed to hold these instances, no matter what types of objects are passed to pickTwo at the call site. The toArray method simply returns this array to pickTwo, which in turn returns it to its caller, so pickTwo will always return an array of type Object[].

当编译这个方法的时候，编译器在给toArray方法传递两个T实例的时候，会生成创建可变参数数组的代码。这个代码会创建一个Object[]类型的数组，不管在调用时，传递给pickTwo方法这些对象类型是什么，Object[]是能保证持有所有实例的最具体的类型了。这个toArray方法也只是简单地将这个数组返回给pickTwo方法，而pickTwo方法也直接将数组返回给了其调用程序，因此pickTwo方法也总是返回类型为Object[]的数组。

> Now consider this main method, which exercises pickTwo:

现在来看看这个使用了pickTwo方法的main方法，如下：

```java
public static void main(String[] args) {
       String[] attributes = pickTwo("Good", "Fast", "Cheap");
}
```

> There is nothing at all wrong with this method, so it compiles without generating any warnings. But when you run it, it throws a ClassCastException, though it contains no visible casts. What you don’t see is that the compiler has generated a hidden cast to String[] on the value returned by pickTwo so that it can be stored in attributes. The cast fails, because Object[] is not a subtype of String[]. This failure is quite disconcerting because it is two levels removed from the method that actually causes the heap pollution (toArray), and the varargs parameter array is not modified after the actual parameters are stored in it.

这个方法没什么错，所有在编译的时候，不会生成任何的警告。但是当你执行它的时候，会抛出ClassCastException，即使代码中不包含可见的转换。我们看不见的转换，是编译器为了将pickTwo的返回值存在attributes里时，生成的将返回值转换为String[]的隐藏转换。这个转换失败了，因为Object[]不是String[]的子类型。这个失败很难被发现，因为距离真正造成堆泄露的地方（toArray），已经隔了好几层调用，而且这个可变参数数组，自真正参数保存在里面以后，确实没有修改过。

> This example is meant to drive home the point that **it is unsafe to give another method access to a generic varargs parameter array,** with two exceptions: it is safe to pass the array to another varargs method that is correctly annotated with @SafeVarargs, and it is safe to pass the array to a non-varargs method that merely computes some function of the contents of the array.

这个例子是为了告诉大家**允许另一个方法访问一个泛型可变参数数组是不安全的**。但又两点意外：把这个数组传递给另一个正确使用@SafeVarargs进行注释的方法是安全的，把这个数组传递给一个只是基于数组的内容做一些计算的非可变参数方法，也是安全的。

> Here is a typical example of a safe use of a generic varargs parameter. This method takes an arbitrary number of lists as arguments and returns a single list containing the elements of all of the input lists in sequence. Because the method is annotated with @SafeVarargs, it doesn’t generate any warnings, on the declaration or at its call sites:

下面是一个安全使用泛型可变参数的一个典型的例子，这个方法的参数是任意多个列表，返回一个包含输入列表中所有元素的单个列表，元素按输入列表排序。由于这个方法是使用了@SafeVarargs注解，因此在其方法声明和被调用的时候，都不会生成警告。方法代码如下：

```java
// Safe method with a generic varargs parameter
   @SafeVarargs
   static <T> List<T> flatten(List<? extends T>... lists) {
       List<T> result = new ArrayList<>();
       for (List<? extends T> list : lists)
           result.addAll(list);
       return result;
   }
```

> The rule for deciding when to use the SafeVarargs annotation is simple: **Use** **@SafeVarargs** **on every method with a varargs parameter of a generic or parameterized type,** so its users won’t be burdened by needless and confusing compiler warnings. This implies that you should *never* write unsafe varargs methods like dangerous or toArray. Every time the compiler warns you of possible heap pollution from a generic varargs parameter in a method you control, check that the method is safe. As a reminder, a generic varargs methods is safe if:
>
> 1. it doesn’t store anything in the varargs parameter array, and
>
> 2. it doesn’t make the array (or a clone) visible to untrusted code. 
>
>    If either of these prohibitions is violated, fix it.

决定什么时候使用SafeVarargs注解的规则很简单：**在每一个可变参数中包含泛型或者参数化类型的方法上都使用@SafeVarargs**，这样，它的用户就不用面对那些没用并且让人困惑的warning了。这也以为这你永远都不应该写像dangerous或者toArray这样的不安全的可变参数方法。当编译器警告你，在你控制的方法的泛型可变参数中可能会有堆污染时，需要检测一下这个方法是否安全。再提醒一下，只有以下这两个条件都满足的时候，泛型可变参数方法才是安全的。

1. 方法没有往可变参数数组中存放任何东西；
2. 方法没有让这个数组（或者其克隆）对其他不可信任的代码可见。

如果违反了这两个禁令中的任何一条，就要立即修正它。

> Note that the SafeVarargs annotation is legal only on methods that can’t be overridden, because it is impossible to guarantee that every possible overriding method will be safe. In Java 8, the annotation was legal only on static methods and final instance methods; in Java 9, it became legal on private instance methods as well.
>
> An alternative to using the SafeVarargs annotation is to take the advice of Item 28 and replace the varargs parameter (which is an array in disguise) with a List parameter. Here’s how this approach looks when applied to our flatten method. Note that only the parameter declaration has changed:

注意，SafeVarargs注解只在不能被覆盖的方法上是合法的，因为不可能保证每一个覆盖后的方法都是安全的。因此，在java8里，SafeVarargs注解只能用在static方法上，或者final实例方法上；在java9里，用在私有实例方法上也变得有效了。

SafeVarargs注解的一个可选的替代方案，是根据Item28的建议，使用列表参数代替可变参数（其本质是一个数组）。下面是这个方法在flatten方法上的应用。需要注意的是，这里只有参数声明被修改了：

```java
// List as a typesafe alternative to a generic varargs parameter 
static <T> List<T> flatten(List<List<? extends T>> lists) {
       List<T> result = new ArrayList<>();
       for (List<? extends T> list : lists)
           result.addAll(list);
       return result;
}
```

> This method can then be used in conjunction with the static factory method List.of to allow for a variable number of arguments. Note that this approach relies on the fact that the List.of declaration is annotated with @SafeVarargs:

这个方法可以和静态工厂方法List.of一起使用，List.of方法可以有数量可变的参数。需要注意的是，这个方法的前提是List.of的声明使用了@SafeVarargs注解。使用代码如下：

```java
audience = flatten(List.of(friends, romans, countrymen));
```

> The advantage of this approach is that the compiler can *prove* that the method is typesafe. You don’t have to vouch for its safety with a SafeVarargs annotation, and you don’t have worry that you might have erred in determining that it was safe. The main disadvantage is that the client code is a bit more verbose and may be a bit slower.
>
> This trick can also be used in situations where it is impossible to write a safe varargs method, as is the case with the toArray method on page 147. Its List analogue *is* the List.of method, so we don’t even have to write it; the Java libraries authors have done the work for us. The pickTwo method then becomes this:

这个方法的优势在于，编译器可以证明这个方法是类型安全的。你不用通过SafeVarargs注解来保证它的安全，也不用担心你可能会错误地认为它是安全的。这个方法主要的缺点在于，这个客户端代码有点啰嗦，运行有点慢。

这个方法还可能用在那些没办法写一个安全的可变参数方法的场景，比如前面的toArray方法，其List对应的方法就是List.of，因此我们甚至不用自己写，java类库作者已经为我们完成了这些工作。这个pickTwo方法就可以变成下面这样：

```java
static <T> List<T> pickTwo(T a, T b, T c) { 
  	switch(rnd.nextInt(3)) {
			case 0: return List.of(a, b); 
      case 1: return List.of(a, c); 
      case 2: return List.of(b, c);
		}
       throw new AssertionError();
   }
```

> and the main method becomes this:

这个main方法就变成这样了：

```java
public static void main(String[] args) {
		List<String> attributes = pickTwo("Good", "Fast", "Cheap");
}
```

> The resulting code is typesafe because it uses only generics, and not arrays.
>
>  In summary, varargs and generics do not interact well because the varargs facility is a leaky abstraction built atop arrays, and arrays have different type rules from generics. Though generic varargs parameters are not typesafe, they are legal. If you choose to write a method with a generic (or parameterized) varargs parameter, first ensure that the method is typesafe, and then annotate it with @SafeVarargs so it is not unpleasant to use.

这样得到的代码是类型安全的，因为它只用了泛型，没有用数组。

总结一下，由于可变参数技术是基于数组的一个技术露底，而数组和泛型在类型规则上有所不同，因此可变参数和泛型不能很好的合作。虽然泛型可变参数不是类型安全的，但是他们是合法的。当你选择要写一个泛型（或者参数化）可变参数方法的时候，第一步就是要确保这个方法是类型安全额，然后使用@SafeVarargs进行注解，这样就能愉快地使用这个方法了。









