### Item25 限制源文件为单个顶级类

> While the Java compiler lets you define multiple top-level classes in a single source file, there are no benefits associated with doing so, and there are significant risks. The risks stem from the fact that defining multiple top-level classes in a source file makes it possible to provide multiple definitions for a class. Which definition gets used is affected by the order in which the source files are passed to the compiler.
>
> To make this concrete, consider this source file, which contains only a Main class that refers to members of two other top-level classes (Utensil and Dessert):

虽然Java的编译器允许在单个源文件中定义多个顶级类，但是这样做没有任何好处。在一个源文件里定义多个顶级类，会出现一个类有多个定义的问题。而具体使用哪个定义，会受到源文件传递给编译器的顺序的影响。

为了具体说明，我们来看一下面这个源文件，它只包含一个Main类，并引用了另外两个顶级类(Utensil 和Dessert)的成员，如下：

```java
public class Main {
       public static void main(String[] args) {
           System.out.println(Utensil.NAME + Dessert.NAME);
       }
}
```

> Now suppose you define both Utensil and Dessert in a single source file named Utensil.java:

现在假设你定义的Utensil和Dessert都在一个名为Utensil.java的源文件里，如下：

```java
// Two classes defined in one file. Don't ever do this!
   class Utensil {
       static final String NAME = "pan";
	 }
   class Dessert {
       static final String NAME = "cake";
	 }
```

> Of course the main program prints pancake. Now suppose you accidentally make *another* source file named Dessert.java that defines the same two classes:

显然Main程序会答应”pancake“，现在假设你有不小心弄了另外一个名为Dessert.java的源文件，也包含这两个类，如下：

```java
// Two classes defined in one file. Don't ever do this!
   class Utensil {
       static final String NAME = "pot";
	 }
   class Dessert {
       static final String NAME = "pie";
	 }
```

> If you’re lucky enough to compile the program with the command javac Main.java Dessert.java, the compilation will fail, and the compiler will tell you that you’ve multiply defined the classes Utensil and Dessert. This is so because the compiler will first compile Main.java, and when it sees the reference to Utensil (which precedes the reference to Dessert), it will look in Utensil.java for this class and find both Utensil and Dessert. When the compiler encounters Dessert.java on the command line, it will pull in that file too, causing it to encounter both definitions of Utensil and Dessert.

如果你使用javac Main.java Dessert.java这个命令来编译这个程序，很幸运，编译会失败，编译器会告诉你，类Utensil和Dessert有多个定义。之所以会这样，是因为编译器首先编译Main.java ，然后就会看到Utensil的引用（在Dessert的引用之前），然后它就会在Utensil.java中寻找Utensil类，然后就发现了Utensil和Dessert两个类。当编译器开始编译命令行中的Dessert.java文件的时候，也会查找这个文件，就会发现Utensil和Dessert这两个类的定义。

> If you compile the program with the command javac Main.java or javac Main.java Utensil.java, it will behave as it did before you wrote the Dessert.java file, printing pancake. But if you compile the program with the command javac Dessert.java Main.java, it will print potpie. The behavior of the program is thus affected by the order in which the source files are passed to the compiler, which is clearly unacceptable.

如果你使用”javac Main.java“或者” javac Main.java Utensil.java“命令来编译程序，结果就会和你写Dessert.java文件之前一样，打印结果为”pancake“。但是，如果你用”javac Dessert.java Main.java“命令来编译程序，它就会打印”potpie“。这个程序的行为会受到源文件传递给编译器的顺序的影响，这显然是不能接受的。

> Fixing the problem is as simple as splitting the top-level classes (Utensil and Dessert, in the case of our example) into separate source files. If you are tempted to put multiple top-level classes into a single source file, consider using static member classes (Item 24) as an alternative to splitting the classes into separate source files. If the classes are subservient to another class, making them into static member classes is generally the better alternative because it enhances readability and makes it possible to reduce the accessibility of the classes by declaring them private (Item 15). Here is how our example looks with static member classes:

要解决这个问题非常简单，只需要把这些顶级类（在前面的例子里，就是Utensil和Dessert）都拆分到单独的源文件里就好了。当你企图把多个顶级类放到一个源文件的时候，也可以考虑使用静态成员类（Item24）来代替将类拆分到不同的源文件里。如果一个类服从于另一个类，那么把这个类写成静态成员类通常来说会更好一些，因为它增强了可读性，同时还可以通过把类设置为private来减少类的可访问性（Item15）。下面是我们的例子，使用静态成员类的样子：

```java
// Static member classes instead of multiple top-level classes
   public class Test {
       public static void main(String[] args) {
           System.out.println(Utensil.NAME + Dessert.NAME);
       }
       private static class Utensil {
           static final String NAME = "pan";
			 }
       private static class Dessert {
           static final String NAME = "cake";
			 }
   }
```

> The lesson is clear: **Never put multiple top-level classes or interfaces in a single source file.** Following this rule guarantees that you can’t have multiple definitions for a single class at compile time. This in turn guarantees that the class files generated by compilation, and the behavior of the resulting program, are independent of the order in which the source files are passed to the compiler.

这个结论很清晰：**永远都不要在一个源文件里写多个顶级类或者接口**。遵守这个规则，就可以保证在编译的时候，单个类不会有多个定义。同时，也保证了编译生成的类文件，以及程序运行的结果，都和源文件传递给编译器的顺序无关。

