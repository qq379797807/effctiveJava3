### Item19 要么专门设计继承并提供文档，要么禁止继承

> Item 18 alerted you to the dangers of subclassing a “foreign” class that was not designed and documented for inheritance. So what does it mean for a class to be designed and documented for inheritance?

在Item18中提醒过我们：继承一个不是专门设计来继承并且文档说明的“外来类”是很危险的。那么问题来了，什么类才是一个专门设计来继承并提供文档说明的类呢？

> First, the class must document precisely the effects of overriding any method. In other words, **the class must document its** **self-use** **of overridable methods.** For each public or protected method, the documentation must indicate which overridable methods the method invokes, in what sequence, and how the results of each invocation affect subsequent processing. (By *overridable*, we mean nonfinal and either public or protected.) More generally, a class must document any circumstances under which it might invoke an overridable method. For example, invocations might come from background threads or static initializers.

首先，这个类必须在文档里准确的描述覆盖每一个方法的影响。换句话说，就是类必须有文档说明其可覆盖方法的自用性（所谓可覆盖的，也就是非final且公有或者受保护的）。也就是说，对于每一个公有的或者受保护的方法，都必须指明其调用的可覆盖的方法，及其调用顺序，以及每一个调用对后续处理产生的影响。更加广义的说，一个类必须文档说明其可覆盖方法可能被调用的所有的场景。比如，后台线程或者静态初始化器可能的调用。

> A method that invokes overridable methods contains a description of these invocations at the end of its documentation comment. The description is in a special section of the specification, labeled “Implementation Requirements,” which is generated by the Javadoc tag @implSpec. This section describes the inner workings of the method. Here’s an example, copied from the specification for java.util.AbstractCollection:

一个调用了可覆盖方法的方法，在其注释文档的末尾，会包含这些调用的描述。这些描述是规范中的一个特殊的部分，写着“Implementation Requirements,”的标签，该标签是通过javadoc标签 @implSpec生成的。这部分描述了这个方法的内部工作。下面是来自java.util.AbstractCollection规范中的一个例子。

> ```java
> public boolean remove(Object o)
> ```
>
> Removes a single instance of the specified element from this collection, if it is present (optional operation). More formally, removes an element e such that Objects.equals(o, e), if this collection contains one or more such elements. Returns true if this collection contained the specified element (or equivalently, if this collection changed as a result of the call).
>
> **Implementation Requirements:** This implementation iterates over the collection looking for the specified element. If it finds the element, it removes the element from the collection using the iterator’s remove method. Note that this implementation throws an UnsupportedOperationException if the iterator returned by this collection’s iterator method does not implement the remove method and this collection contains the specified object.

```java
public boolean remove(Object o)
```

​		如果集合中存在指定的元素，就从集合中删除指定元素的单个实例（这是一个可选的操作）。比较正式地		说，如果集合中包含一个或者多个元素满足Objects.equals(o, e)，就从集合中删掉一个这样的元素。当集合		中包含这个指定元素的时候，返回true（当集合因为这次调用发生变化的时候，也返回true）。

​		**实现要求**：这个实现必须遍历整个集合来寻找指定的元素。如果找到了这个元素，就调用iterator的remove		方法来从集合中删除这个元素。需要注意的是，当这个集合的iterator方法返回的iterator不支持remove方		法，且集合包含这个指定元素的时候，会抛出UnsupportedOperationException。

> This documentation leaves no doubt that overriding the iterator method will affect the behavior of the remove method. It also describes exactly how the behavior of the Iterator returned by the iterator method will affect the behavior of the remove method. Contrast this to the situation in Item 18, where the programmer subclassing HashSet simply could not say whether overriding the add method would affect the behavior of the addAll method.

这个文档清楚地说明了重写iterator方法将会影响到remove方法的行为。还确切地描述了iterator方法返回的iterator是如何影响remove方法的。而在Item18中的情形中，程序员在继承HashTable的时候，不能简单地得知覆盖add方法将会影响到addAll方法的行为。

> But doesn’t this violate the dictum that good API documentation should describe *what* a given method does and not *how* it does it? Yes, it does! This is an unfortunate consequence of the fact that inheritance violates encapsulation. To document a class so that it can be safely subclassed, you must describe implementation details that should otherwise be left unspecified.

有一个关于API文档的宣言说：一个好得API文档应该描述这个方法做了什么，而不是如何做的。上面的情况是不是违反了这一宣言？是的，确实违反了。这是继承打破了封装性，所带来的一个不好的结果。为了当这个类可以安全地被继承，在其文档中，必须描述这些有可能还没有定义的实现细节。

> The @implSpec tag was added in Java 8 and used heavily in Java 9. This tag should be enabled by default, but as of Java 9, the Javadoc utility still ignores it unless you pass the command line switch 

标签@implSpec实在Java8中添加的，在Java9中得到了广泛的应用。这个标签应该是默认可用的，但是在Java9中，javadoc工具还是会忽略它，除非传入这样的命令行参数：

```
-tag "apiNote:a:API Note:".
```

> Designing for inheritance involves more than just documenting patterns of self-use. To allow programmers to write efficient subclasses without undue pain, **a class may have to provide hooks into its internal workings in the form of judiciously chosen protected methods** or, in rare instances, protected fields. For example, consider the removeRange method from java.util.AbstractList:

为了继承而进行的设计不仅仅包括写文档说明自用模式。为了让程序员可以比较容易地编写出有效的子类，**一个类可能必须要精心挑选一些受保护的方法，来提供适当的钩子，以便进入内部工作中**。或者极少数的时候会以实例或受保护的域的形式。比如java.util.AbstractList类的中removeRange方法。其文档如下：

> ```java
> protected void removeRange(int fromIndex, int toIndex)
> ```
>
> Removes from this list all of the elements whose index is between fromIndex, inclusive, and toIndex, exclusive. Shifts any succeeding elements to the left (reduces their index). This call shortens the list by (toIndex - fromIndex) elements. (If toIndex == fromIndex, this operation has no effect.)
>
> This method is called by the clear operation on this list and its sublists. Overriding this method to take advantage of the internals of the list implementation can substantially improve the performance of the clear operation on this list and its sublists.
>
> **Implementation Requirements:** This implementation gets a list iterator positioned before fromIndex and repeatedly calls ListIterator.next followed by ListIterator.remove, until the entire range has been removed. **Note: If** **ListIterator.remove** **requires linear time, this implementation requires quadratic time.**
>
> Parameters:
>
> ​	fromIndex index of first element to be removed. 
>
> ​	toIndex index after last element to be removed.

```java
protected void removeRange(int fromIndex, int toIndex)
```

删除列表中索引位置在fromIndex和toIndex之间的元素，包含fromIndex，不包含toIndex。并将后面剩下的		元素移到左边。这个方法的调用会将列表缩短toIndex-fromIndex个元素。（如果toIndex等于fromIndex的		话，这个操作就不会有什么影响）。

这个方法会被列表及其子列表的clear操作调用。因此，利用列表的内部实现特点覆盖这个方法，可以有效的提升列表及其子列表的clear操作的性能。

**实现要求**：这个方法是这样实现的：获得了一个处在fromIndex前的列表iterator，然后重复地调用ListIterator.next和ListIterator.remove方法，直到整个范围的元素都已经被删除。需要注意的是：**如果ListIterator.remove需要线性时间复杂度，那么这个方法的实现就需要平方级的时间复杂度**。

参数：

​		fromIndex 需要被删除的第一个元素的索引

​		toIndex 需要删除的最后一个元素的后面的索引

> This method is of no interest to end users of a List implementation. It is provided solely to make it easy for subclasses to provide a fast clear method on sublists. In the absence of the removeRange method, subclasses would have to make do with quadratic performance when the clear method was invoked on sublists or rewrite the entire subList mechanism from scratch—not an easy task!

这个方法对于列表的最终用户而言，没什么意义。它只是用来让子类编写子列表的快速clear方法更加容易的。如果没有removeRange方法，在子列表上调用clear方法的时候，必须忍受平方级的时间复杂度；或者从头重写整个子列表机制——这是一个不容易的事情。

> So how do you decide what protected members to expose when you design a class for inheritance? Unfortunately, there is no magic bullet. The best you can do is to think hard, take your best guess, and then test it by writing subclasses. You should expose as few protected members as possible because each one represents a commitment to an implementation detail. On the other hand, you must not expose too few because a missing protected member can render a class practically unusable for inheritance.

那么当你要设计一个用于继承的类的时候，要怎么去决定需要暴露的受保护的成员呢？遗憾的是，并没有神奇的法则可以参考。你能做地做好的方式就是努力思考，发挥你的想象力，然后写子类进行测试。一方面，你应该尽可能少的暴露这种受保护的成员，因为每一个成员都代表一个对实现细节的承诺。另一方面，你也不能暴露太少这种受保护的成员，因为缺少这种受保护的成员会使对这个类的继承变得没什么用处。

> **The** **only** **way to test a class designed for inheritance is to write subclasses.** If you omit a crucial protected member, trying to write a subclass will make the omission painfully obvious. Conversely, if several subclasses are written and none uses a protected member, you should probably make it private. Experience shows that three subclasses are usually sufficient to test an extendable class. One or more of these subclasses should be written by someone other than the superclass author.

测试一个专为继承设计的类的唯一的方法就是编写子类。如果你漏掉了一个至关重要的受保护成员，当你试图写一个子类的时候，就会很容易发现。相反，如果你写的几个子类都没有用到一个受保护的成员，这个时候，你就该考虑把它改为私有的了。实验结果显示，通常3个子类就足够测试一个可继承的类了。其中的一个或者多个子类，应该有其他的程序员来写，而不是编写超类的作者自己来写。

> When you design for inheritance a class that is likely to achieve wide use, realize that you are committing *forever* to the self-use patterns that you document and to the implementation decisions implicit in its protected methods and fields. These commitments can make it difficult or impossible to improve the performance or functionality of the class in a subsequent release. Therefore, **you must test your class by writing subclasses** **before** **you release it.**

当你在设计一个可能被广泛使用的用来继承的类的时候，必须要意识到，你已经对文档中的自用模式和受保护方法和域中的内在实现细节都做出了永久的承诺。这些承诺或使得你在后面的版本中，要提升性能或者功能，都会变得很困难甚至不可能。**因此在你发布这个类之前，必须要写子类来测试你的类**。

> Also, note that the special documentation required for inheritance clutters up normal documentation, which is designed for programmers who create instances of your class and invoke methods on them. As of this writing, there is little in the way of tools to separate ordinary API documentation from information of interest only to programmers implementing subclasses.

还需要注意的是，为了继承需要的特殊的文档会让正常的文档变成乱七八糟，正常的文档是指那些设计来给创建类的实例并调用其方法的程序员看的文档。在编写这本书的时候，还没有一个好的工具可以把“普通的API”和“让实现子类的程序员才感兴趣的API”分开来。

> There are a few more restrictions that a class must obey to allow inheritance. **Constructors must not invoke overridable methods,** directly or indirectly. If you violate this rule, program failure will result. The superclass constructor runs before the subclass constructor, so the overriding method in the subclass will get invoked before the subclass constructor has run. If the overriding method depends on any initialization performed by the subclass constructor, the method will not behave as expected. To make this concrete, here’s a class that violates this rule:

为了允许继承，这里还有几条必须遵守的约束。**构造器中不能直接或间接地调用可以覆盖的方法**。如果你违反了这个规则，程序就可能出错。父类构造器会在子类构造器之前执行，因此子类中的覆盖的方法将会在子类构造器执行之前被调用。如果这个覆盖方法依赖了子类构造器中的一些初始化操作，这个方法就不会像预期地那样执行。为了说得更明确一下，下面是一个违反了这个规则的类：

```java
public class Super {
       // Broken - constructor invokes an overridable method
       public Super() {
           overrideMe();
       }
       public void overrideMe() {
       }
}
```

> Here’s a subclass that overrides the overrideMe method, which is erroneously invoked by Super’s sole constructor:

下面是一个覆盖了overrideMe方法的子类，overrideMe方法在超类的唯一的构造器中被错误的调用了。

```java
public final class Sub extends Super {
       // Blank final, set by constructor
       private final Instant instant;
       Sub() {
           instant = Instant.now();
			 }
       // Overriding method invoked by superclass constructor
       @Override public void overrideMe() {
           System.out.println(instant);
			 }
       public static void main(String[] args) {
           Sub sub = new Sub();
           sub.overrideMe();
			 } 
}
```

> You might expect this program to print out the instant twice, but it prints out null the first time because overrideMe is invoked by the Super constructor before the Sub constructor has a chance to initialize the instant field. Note that this program observes a final field in two different states! Note also that if overrideMe had invoked any method on instant, it would have thrown a NullPointerException when the Super constructor invoked overrideMe. The only reason this program doesn’t throw a NullPointerException as it stands is that the println method tolerates null parameters.
>
> Note that it *is* safe to invoke private methods, final methods, and static methods, none of which are overridable, from a constructor.

你可能会 希望这程序打印两次日期，但是它第一次打印的却是null。因为在子类构造器初始化instant域之前，overrideMe方法就在父类构造器中被调用了。需要注意的是这个程序就观察到了一个final域有两个状态！还需要注意的是，如果overrideMe方法如果调用了instant的方法，当父类构造器调用overrideMe的时候，就会抛出NullPointerException。这个程序之所以没有抛出NullPointerException，是因为println容许参数为null。

注意，在构造器中，调用私有方法，final方法，以及静态方法这些不会被覆盖的方法都是安全的。

> The Cloneable and Serializable interfaces present special difficulties when designing for inheritance. It is generally not a good idea for a class designed for inheritance to implement either of these interfaces because they place a substantial burden on programmers who extend the class. There are, however, special actions that you can take to allow subclasses to implement these interfaces without mandating that they do so. These actions are described in Item 13 and Item 86.

在设计一个用于继承的类的时候，Cloneable和Serializable接口会带来特殊的麻烦。通常来说，用于继承的类实现这两个接口中的任何一个都不太好，因为它会给要继承这个类的程序员带来一些显著的麻烦。但是，还是可以采取一些办法让这些子类可以实现这些接口，而不用承受这些负担，这些方法在[Item13](# Item13inheritance)中和Item86中有介绍。

> If you do decide to implement either Cloneable or Serializable in a class that is designed for inheritance, you should be aware that because the clone and readObject methods behave a lot like constructors, a similar restriction applies: **neither** **clone** **nor** **readObject** **may invoke an overridable method, directly or indirectly.** In the case of readObject, the overriding method will run before the subclass’s state has been deserialized. In the case of clone, the overriding method will run before the subclass’s clone method has a chance to fix the clone’s state. In either case, a program failure is likely to follow. In the case of clone, the failure can damage the original object as well as the clone. This can happen, for example, if the overriding method assumes it is modifying the clone’s copy of the object’s deep structure, but the copy hasn’t been made yet.

如果你已经决定了要在为了继承设计的类上实现Cloneable接口或者Serializable接口，你就必须意识到clone方法和readObject方法和构造器有些类似，都需要遵守一个类似的规定：在clone和readObject方法里都不要直接或间接地调用可覆盖的方法。对于readObject而言，覆盖后的方法会在子类状态反序列化之前就执行，对于clone方法而言，覆盖后的方法会在clone方法有机会修改clone对象的状态之前就执行。在这些情况下，程序都可能会出错。针对clone，这种错误可能会破坏原始对象和克隆对象。比如，当覆盖后的方法假设它修改的对象是原对象通过深层复制后的对象时，就可能出现这种问题，因为这个时候还没有进行深层复制。

> Finally, if you decide to implement Serializable in a class designed for inheritance and the class has a readResolve or writeReplace method, you must make the readResolve or writeReplace method protected rather than private. If these methods are private, they will be silently ignored by subclasses. This is one more case where an implementation detail becomes part of a class’s API to permit inheritance.

最后，如果你决定要让一个为了继承设计的类实现Serializable接口，且这个类有一个readResolve方法或者writeReplace方法，你必须把这两个方法设为受保护的，而不是私有的。如果它们是私有的，那么子类就会直接忽略掉它们。这也正式一种“为了允许继承让实现细节变成类的API的一部分”的一种方法。

> By now it should be apparent that **designing a class for inheritance requires great effort and places substantial limitations on the class.** This is not a decision to be undertaken lightly. There are some situations where it is clearly the right thing to do, such as abstract classes, including *skeletal implementations* of interfaces (Item 20). There are other situations where it is clearly the wrong thing to do, such as immutable classes (Item 17).

到现在，结论就已经很明显了：**要设计一个用于继承的类需要更大的努力，还会给这个类带来一些明显的限制。**因此这不是一个可以很轻松就决定的事情。在一些场景里，很明显需要继承，比如抽象类，包括接口（Item20）的“骨架实现”。也有另外一些场景，很显然不需要继承，比如不可变类（Item17）。

> But what about ordinary concrete classes? Traditionally, they are neither final nor designed and documented for subclassing, but this state of affairs is dangerous. Each time a change is made in such a class, there is a chance that subclasses extending the class will break. This is not just a theoretical problem. It is not uncommon to receive subclassing-related bug reports after modifying the internals of a nonfinal concrete class that was not designed and documented for inheritance.

但是，对于那些普通的具体类该怎么办呢？一般来说，它们既没有声明为final，也不是专门为了继承而设计的，没有文档说明，这种状况就很危险。这种类的每次修改，都可能导致继承它的类崩溃。这不仅仅是一个理论问题，修改完一个不是为继承设计，也没有文档说明的、非final的具体类后，通常都会收到一些子类相关的bug报告。

> **The best solution to this problem is to prohibit subclassing in classes that are not designed and documented to be safely subclassed.** There are two ways to prohibit subclassing. The easier of the two is to declare the class final. The alternative is to make all the constructors private or package-private and to add public static factories in place of the constructors. This alternative, which provides the flexibility to use subclasses internally, is discussed in Item 17. Either approach is acceptable.

**解决这个问题最好的方法就是禁止“那些不是设计来继承且没有文档保证其安全性的类”被子类化**。有两种方法可以禁止子类化。最简单的方法就是声明类为final。另一个是把所有的构造器都设为私有的或者包级私有的，并添加静态工厂方法来替代构造器。后面这种方法保留了内部使用子类的灵活性，在Item17中也讨论过。这两种方法都是可以接受的。

> This advice may be somewhat controversial because many programmers have grown accustomed to subclassing ordinary concrete classes to add facilities such as instrumentation, notification, and synchronization or to limit functionality. If a class implements some interface that captures its essence, such as Set, List, or Map, then you should feel no compunction about prohibiting subclassing. The *wrapper class* pattern, described in Item 18, provides a superior alternative to inheritance for augmenting the functionality.

由于很多程序员已经习惯了通过子类化普通具体类来增加一些功能，比如仪表功能（前面提到的计数功能）、通知功能、同步功能等，又或者是限制原有类的一些功能。如果一个类实现的接口可以刻画其本质，比如Set、List、Map，这时候就不应该因为禁止子类化而感到不舒服。因为对于这种情况，在Item18中介绍的装饰者模式，可以新增一些功能，是代替继承的一个很好的选择。

> If a concrete class does not implement a standard interface, then you may inconvenience some programmers by prohibiting inheritance. If you feel that you must allow inheritance from such a class, one reasonable approach is to ensure that the class never invokes any of its overridable methods and to document this fact. In other words, eliminate the class’s self-use of overridable methods entirely. In doing so, you’ll create a class that is reasonably safe to subclass. Overriding a method will never affect the behavior of any other method.

如果这个具体类并没有实现一个标准的接口，这时候禁止继承的话，可能会给一些程序员带来不便。如果你觉得这个类必须要允许继承的话，有一个合理的方法是保证这个类永远不会调用其可覆盖的方法，并且写文档说明。换句话说，就是要完全消除这个类的可覆盖方法的自用性。这样做的话，你就会创建一个可以安全的子类化的类。覆盖其中的方法将永远不会影响到其他的方法的行为。

> You can eliminate a class’s self-use of overridable methods mechanically, without changing its behavior. Move the body of each overridable method to a private “helper method” and have each overridable method invoke its private helper method. Then replace each self-use of an overridable method with a direct invocation of the overridable method’s private helper method.

你可以通过以下的方法，消除可覆盖方法的自用性，且不改变其行为：把每个可覆盖方法的内容直接移动到一个私有的“帮助方法”里，然后可覆盖方法直接调用其私有帮助方法。然后将每一个调用可覆盖方法的语句 改为 其对应的私有帮助方法的直接调用。

> In summary, designing a class for inheritance is hard work. You must document all of its self-use patterns, and once you’ve documented them, you must commit to them for the life of the class. If you fail to do this, subclasses may become dependent on implementation details of the superclass and may break if the implementation of the superclass changes. To allow others to write *efficient* subclasses, you may also have to export one or more protected methods. Unless you know there is a real need for subclasses, you are probably better off prohibiting inheritance by declaring your class final or ensuring that there are no accessible constructors.

总结一下，专门为继承设计类是一项很困难的工作。你必须要用文档说明其所有的自用模式，并且一旦你建立了文档，在这个类的生命周期内，你就必须遵守这些文档。如果你没有做到的话，当你修改了父类的实现时，那些依赖父类实现细节的子类就会被破坏。为了让其他人可以编写高效的子类，你必须要提供一个或者多个受保护的方法。除非你知道这个类确实需要被子类化，否则你最好是通过声明类为final或者保证没有可访问的构造器来禁止继承。